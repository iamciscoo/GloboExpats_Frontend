# Front-End Architecture & Flow

> Version: 2024-06-13 – _living document_

This file gives a **plain-English tour** of the codebase so that non-React engineers (e.g. backend, QA, PM) can understand how screens are composed, how data moves, and where integrations will slot in. You do **not** need to know JSX to follow along.

---

## 1. Folder Layout Cheat-Sheet

| Path             | What lives here                                                      | Runtime            | Notes                                                                                                                                       |
| ---------------- | -------------------------------------------------------------------- | ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------- |
| `app/`           | Every **page** (URL) in the product                                  | Server by default  | Next.js 15 _App Router_. Folders map to routes. `page.tsx` → a page, `layout.tsx` → wrapper, `loading.tsx` / `error.tsx` → built-in states. |
| `components/`    | **Reusable UI blocks** such as _Header_, _Carousel_, _MessageDialog_ | Client or Server\* | Generic building blocks referenced by pages.                                                                                                |
| `components/ui/` | Atom-level widgets generated by shadcn/ui (button, card, etc.)       | Client             | Pure presentation.                                                                                                                          |
| `providers/`     | React **context providers** for shared state (e.g. cart, theme)      | Client             | Loaded once in the root layout.                                                                                                             |
| `hooks/`         | Custom helper functions (e.g. `useAuth`, `useSearch`)                | Client             | Encapsulate logic.                                                                                                                          |
| `app/api/`       | **Mock REST endpoints**                                              | Server (Edge)      | Temporary in-memory data so pages work offline. To be replaced with real backend calls.                                                     |
| `docs/`          | Architecture & developer docs (this file!)                           | —                  | Not shipped.                                                                                                                                |

> _Server vs. Client_: A file becomes a **Client Component** only if it contains the directive `'use client'` at the top. Those run in the browser and can use React state, effects, etc.

---

## 2. Page Flow in Three Levels

1. **Public browsing** – `app/page.tsx` (home), `app/browse`, `app/category/[slug]`, `app/product/[id]`, etc. These pages use _Server Components_ ➜ fetched and rendered on the server, then streamed as HTML for fast first paint.
2. **Transactional flows** – Cart & checkout (`app/cart`, `app/checkout`, `app/checkout/success`), seller dashboard (`app/seller/**`) and account management (`app/account/**`). Most still server-render, but embed **client sub-components** for interactivity (e.g. quantity selectors, tabs).
3. **Authenticated utilities** – Messages, notifications, admin dashboard. These rely on a forthcoming `useAuth` provider to inject JWT/user info and guard routes.

---

## 3. How a Page Renders

Example: `/product/123`

1. `app/product/[id]/page.tsx` executes **server-side**:
   ```ts
   // Simplified
   const ProductPage = async ({ params }) => {
     const product = await fetch(`http://internal-api/products/${params.id}`, { cache: 'no-store' })
     return <ProductDetail product={product} />
   }
   ```
2. It passes data into `components/ui/ProductDetail` (a client component) for fancy interactions (carousel, add-to-cart button).
3. Shared wrappers such as `app/layout.tsx` add the global `<Header>` and `<Footer>`.

---

## 4. State Providers

| Provider              | Purpose                                    | Where initialized                          |
| --------------------- | ------------------------------------------ | ------------------------------------------ |
| `ThemeProvider`       | Light/dark toggle using `next-themes`      | `app/layout.tsx`                           |
| `CartProvider`        | Keeps cart items in localStorage + context | `app/layout.tsx`                           |
| `AuthProvider` (stub) | Will hold JWT & user info                  | TODO – `app/layout.tsx` once backend ready |

Access pattern inside any component:

```ts
const { items, addItem } = useCart()
```

---

## 5. Replacing the Mock API with Real Endpoints

1. **Delete** folders in `app/api/*` once you have a true backend.
2. Create a small wrapper in `lib/http.ts`:
   ```ts
   export async function api<T>(path: string, init?: RequestInit): Promise<T> {
     const token = typeof window !== 'undefined' ? localStorage.getItem('token') : undefined
     const headers = {
       'Content-Type': 'application/json',
       ...(token && { Authorization: `Bearer ${token}` }),
     }
     const res = await fetch(`${process.env.NEXT_PUBLIC_API_URL}${path}`, { ...init, headers })
     if (!res.ok) throw await res.json()
     return res.json()
   }
   ```
3. Replace calls like `fetch('/api/payment-methods')` with `api('/payment-methods')`.
4. Swap cart & auth providers to hit real endpoints (see `docs/backend.md` for contracts).
5. Because pages are primarily **Server Components**, switching data source won't affect the UI layer—only the fetch URL changes.

---

## 6. Non-Breaking Backend Integration Strategy

| Step                                    | Risk of breakage | Mitigation                                                                                  |
| --------------------------------------- | ---------------- | ------------------------------------------------------------------------------------------- |
| Keep response shapes identical to mocks | Low              | Contract tested via `vitest` as typed DTOs.                                                 |
| Introduce auth                          | Medium           | Wrap protected pages with `AuthGuard` that checks `useAuth.user`; show 401 page if missing. |
| Pagination/filters                      | Low              | Existing components already read `total` and `page` fields; just supply them.               |
| Real-time chat                          | Med-High         | Implement WebSocket in `MessagesClient`; graceful fallback to polling is already coded.     |

---

## 7. Building & Deploying

```bash
pnpm install           # one-time
pnpm dev               # local dev at http://localhost:3000
pnpm build && pnpm start  # production preview
```

Environment variables (see `.env.example`):

```
NEXT_PUBLIC_API_URL=https://api.globalexpat.io
JWT_SECRET=…
```

---

## 8. Where to Start Hacking

- Add real auth logic in `hooks/use-auth.ts` and wire it into `providers/AuthProvider`.
- Replace `app/api/*` mocks with real calls via `lib/http.ts`.
- Flesh out database models – see `docs/database-mongodb.md` next.

---

_Questions? Ping `@frontend` in Slack._
